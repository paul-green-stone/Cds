#include "../include/Graph.h"

#include <string.h>
#include <stdio.h>

/* ================================================================ */
/* ============================ STATIC ============================ */
/* ================================================================ */

/**
 * A structure that holds internal state information for the graph,
 * including the number of vertices, edges, and the last error code.
 */
struct information {

    size_t vertices;
    size_t edges;

    /* Last error code generated by graph operations */
    int last_error_code;
};

/* ================================================================ */
/* ======================== IMPLEMENTATION ======================== */
/* ================================================================ */

int Graph_init(Graph* graph, int (*match)(const void* key1, const void* key2), void (*destoy)(void* data)) {

    if (graph == NULL) { return -1; }

    if ((graph->_info = calloc(1, sizeof(struct information))) == NULL) { return -2; }

    graph->match = match;
    graph->destroy = destoy;

    ((struct information*) graph->_info)->vertices = 0;
    ((struct information*) graph->_info)->edges = 0;

    /* Initialize the list of adjacency-list structures */
    sList_init(&graph->vertices, NULL, NULL);

    /* ======== */
    return 0;
}

/* ================================================================ */

int Graph_destroy(Graph* graph) {

    Vertex* vertex = NULL;
    /* ======== */

    if (graph == NULL) { return -1; }

    /* Remove each adjacency-list structure and destroy its adjacency list */
    while (graph->vertices.size > 0) {

        if ((vertex = sList_remove_first(&graph->vertices)) != NULL) {

            Set_destroy(&vertex->vertices);

            if (graph->destroy != NULL) { graph->destroy(vertex->data); }

            free(vertex);
        }
    }

    /* Destroy the list of adjacency-list structures, which is now empty */
    sList_destroy(&graph->vertices);
    /* Destroy the internal container holding graph state information */
    free(graph->_info);
    /* No operations are allowed now, but clear the structure as a precaution */
    memset(graph, 0, sizeof(Graph));

    /* ======== */
    return 0;
}

/* ================================================================ */

int Graph_add_V(Graph* graph, const void* data) {

    Vertex* vertex = NULL;
    int retval;
    /* ======== */

    if (graph == NULL) { return -1; }

    /* Do not allow the insertion of duplicate vertices */
    for (sNode* node = graph->vertices.head; node != NULL; node = sNode_next(node)) {
        if (graph->match(data, ((Vertex*) sNode_data(node))->data)) { return 1; }
    }

    /* Insert the vertex */
    if ((vertex = calloc(1, sizeof(Vertex))) == NULL) { return -2; }

    vertex->data = (void*) data;
    sList_init(&vertex->vertices, NULL, graph->match);

    if ((retval = sList_insert_last(&graph->vertices, vertex)) != SLIST_OK) { return retval; }

    ((struct information*) graph->_info)->vertices++;

    /* ======== */
    return 0;
}

/* ================================================================ */

int Graph_add_E(Graph* graph, const void* data1, const void* data2) {

    sNode* node = NULL;
    int retval;
    /* ======== */

    if (graph == NULL) { return -1; }

    /* Do not allow insertion of an edge without both its vertices in the graph */
    for (node = graph->vertices.head; node != NULL; node = sNode_next(node)) {
        if (graph->match(data2, ((Vertex*) sNode_data(node))->data)) { break ; }
    }

    if (node == NULL) { return -1; }

    for (node = graph->vertices.head; node != NULL; node = sNode_next(node)) {
        if (graph->match(data1, ((Vertex*) sNode_data(node))->data)) { break ; }
    }

    if (node == NULL) { return -1; }

    /* Insert the second vertex into the adjacency list of the first vertex */
    if ((retval = Set_insert(&((Vertex*) sNode_data(node))->vertices, data2)) != 0) { return retval; }

    /* Adjust the edge count to account for the inserted edge */
    ((struct information*) graph->_info)->edges++;

    /* ======== */
    return 0;
}

/* ================================================================ */

int Graph_del_V(Graph* graph, void** data) {

    sNode* node = NULL, *temp = NULL, *prev = NULL;
    Vertex* vertex;
    int found = 0;
    /* ======== */

    if (graph == NULL) { return -1; }

    /* Traverse each adjacency list and the vertices it contains */
    for (node = graph->vertices.head; node != NULL; node = sNode_next(node)) {

        /* Do not allow removal of the vertex if it is in an adjacency list */
        if (Set_is_member(&((Vertex*) sNode_data(node))->vertices, *data)) { return -1; }

        /* Keep a pointer to the vertex to be removed */
        if (graph->match(*data, ((Vertex*) sNode_data(node))->data)) {

            temp = node;
            found = 1;
        }

        /* Keep a pointer to the vertex before the vertex to be removed */
        if (!found) { prev = node; }
    }

    /* Return if the vertex was not found */
    if (!found) { return -1; }

    /* Do not allow removal of the vertex if its adjacency list is not empty */
    if (((Vertex*) sNode_data(temp))->vertices.size > 0) { return -1; }

    /* Remove the vertex */
    if ((vertex = sList_remove(&graph->vertices, temp)) == NULL) { return -1; }

    *data = vertex->data;
    /* Free the storage allocated by the abstract datatype */
    free(vertex);

    ((struct information*) graph->_info)->vertices--;

    /* ======== */
    return 0;
}

/* ================================================================ */

int Graph_del_E(Graph* graph, const void* data1, const void** data2) {

    sNode* node = NULL;
    /* ======== */

    /* Locate the adjacency list for the first vertex */
    for (node = graph->vertices.head; node != NULL; node = sNode_next(node)) {
        if (graph->match(data1, ((Vertex*) sNode_data(node))->data)) { break ; }
    }

    if (node == NULL) { return -1; }

    /* Remove the second vertex from the adjacency list of the first vertex */
    if ((*data2 = Set_remove(&((Vertex*) sNode_data(node))->vertices, *data2)) == NULL) { return -1; }

    /* Adjust the edge count to account for the removed edge */
    ((struct information*) graph->_info)->edges--;

    /* ======== */
    return 0;
}

/* ================================================================ */

int Graph_get_adjl(const Graph* graph, const void* data, Vertex** vertex) {

    sNode* node = NULL, *prev = NULL;
    /* ======== */

    /* Locate the adjacency list for the vertex */
    for (node = graph->vertices.head; node != NULL; node = sNode_next(node), prev = node) {
        if (graph->match(data, ((Vertex*) sNode_data(node))->data)) { break ; }
    }

    /* Return if the vertex was not found */
    if (node == NULL) { return -1; }

    /* Pass back the adjacency list for the vertex */
    *vertex = sNode_data(node);

    /* ======== */
    return 0;
}

/* ================================================================ */

int Graph_is_adjacent(const Graph* graph, const void* data1, const void* data2) {

    sNode* node = NULL, *prev = NULL;
    /* ======== */

    /* Locate the adjacency list of the first vertex */
    for (node = graph->vertices.head; node != NULL; node = sNode_next(node), prev = node) {
        if (graph->match(data1, ((Vertex*) sNode_data(node))->data)) { break ; }
    }

    /* Return if the first vertex was not found */
    if (node == NULL) { return -1; }

    /* ======== */
    /* Return whether the second vertex is in the adjacency list of the first */
    return Set_is_member(&((Vertex*) sNode_data(node))->vertices, data2);
}

/* ================================================================ */

ssize_t Graph_edges(const Graph* graph) {
    return graph ? ((struct information*) graph->_info)->edges : -1;
}

/* ================================================================ */

ssize_t Graph_vertices(const Graph* graph) {
    return graph ? ((struct information*) graph->_info)->vertices : -1;
}